var SONG_DATA_ARRAY = [
  43,
  50,
  59,
  57,
  59,
  50,
  59,
  50,
  43,
  50,
  59,
  57,
  59,
  50,
  59,
  50,
  43,
  52,
  60,
  59,
  60,
  52,
  60,
  52,
  43,
  52,
  60,
  59,
  60,
  52,
  60,
  52,
  43,
  54,
  60,
  59,
  60,
  54,
  60,
  54,
  43,
  54,
  60,
  59,
  60,
  54,
  60,
  54,
  43,
  55,
  59,
  57,
  59,
  55,
  59,
  55,
  43,
  55,
  59,
  57,
  59,
  55,
  59,
  54,
  43,
  52,
  59,
  57,
  59,
  55,
  54,
  55,
  52,
  55,
  54,
  55,
  47,
  50,
  49,
  47,
  49,
  55,
  57,
  55,
  57,
  55,
  57,
  55,
  49,
  55,
  57,
  55,
  57,
  55,
  57,
  55,
  54,
  57,
  62,
  61,
  62,
  57,
  55,
  57,
  54,
  57,
  55,
  57,
  50,
  54,
  52,
  50,
  40,
  47,
  55,
  54,
  55,
  47,
  55,
  47,
  40,
  47,
  55,
  54,
  55,
  47,
  55,
  47,
  40,
  49,
  50,
  52,
  50,
  49,
  47,
  45,
  55,
  54,
  52,
  62,
  61,
  59,
  57,
  55,
  54,
  52,
  50,
  62,
  57,
  62,
  54,
  57,
  50,
  52,
  54,
  57,
  55,
  54,
  52,
  50,
  56,
  50,
  53,
  52,
  53,
  50,
  56,
  50,
  59,
  50,
  53,
  52,
  53,
  50,
  56,
  50,
  48,
  52,
  57,
  59,
  60,
  57,
  52,
  50,
  48,
  52,
  57,
  59,
  60,
  57,
  54,
  52,
  51,
  54,
  51,
  54,
  57,
  54,
  57,
  54,
  51,
  54,
  51,
  54,
  57,
  54,
  57,
  54,
  55,
  54,
  52,
  55,
  54,
  55,
  57,
  54,
  55,
  54,
  52,
  50,
  48,
  47,
  45,
  43,
  42,
  48,
  50,
  48,
  50,
  48,
  50,
  48,
  42,
  48,
  50,
  48,
  50,
  48,
  50,
  48,
  43,
  47,
  53,
  52,
  53,
  47,
  53,
  47,
  43,
  47,
  53,
  52,
  53,
  47,
  53,
  47,
  43,
  48,
  52,
  50,
  52,
  48,
  52,
  48,
  43,
  48,
  52,
  50,
  52,
  48,
  52,
  48,
  43,
  54,
  60,
  59,
  60,
  54,
  60,
  54,
  43,
  54,
  60,
  59,
  60,
  54,
  60,
  54,
  43,
  50,
  59,
  57,
  59,
  55,
  54,
  52,
  50,
  48,
  47,
  45,
  43,
  42,
  40,
  38,
  37,
  45,
  52,
  54,
  55,
  52,
  54,
  55,
  37,
  45,
  52,
  54,
  55,
  52,
  54,
  55,
  36,
  45,
  50,
  52,
  54,
  50,
  52,
  54,
  36,
  45,
  50,
  52,
  54,
  50,
  52,
  54,
  36,
  45,
  50,
  54,
  57,
  61,
  62,
  -1,
  -1,
  45,
  47,
  48,
  50,
  52,
  54,
  55,
  57,
  54,
  50,
  52,
  54,
  55,
  57,
  59,
  60,
  57,
  54,
  55,
  57,
  59,
  60,
  62,
  63,
  62,
  61,
  62,
  62,
  60,
  59,
  60,
  60,
  57,
  54,
  52,
  50,
  45,
  47,
  48,
  38,
  45,
  50,
  54,
  57,
  59,
  60,
  57,
  59,
  55,
  50,
  48,
  47,
  43,
  45,
  47,
  38,
  43,
  47,
  50,
  55,
  57,
  59,
  55,
  61,
  59,
  57,
  58,
  58,
  57,
  56,
  57,
  57,
  55,
  54,
  55,
  55,
  52,
  49,
  47,
  45,
  49,
  52,
  55,
  57,
  61,
  62,
  61,
  62,
  57,
  54,
  52,
  54,
  57,
  50,
  54,
  45,
  50,
  49,
  47,
  45,
  43,
  42,
  40,
  38,
  -1,
  60,
  59,
  57,
  55,
  54,
  52,
  50,
  60,
  59,
  57,
  55,
  54,
  52,
  50,
  48,
  59,
  57,
  55,
  54,
  52,
  50,
  48,
  47,
  57,
  55,
  54,
  52,
  50,
  48,
  47,
  45,
  55,
  54,
  52,
  54,
  57,
  50,
  57,
  52,
  57,
  54,
  57,
  55,
  57,
  52,
  57,
  54,
  57,
  50,
  57,
  55,
  57,
  52,
  57,
  54,
  57,
  50,
  57,
  55,
  57,
  52,
  57,
  54,
  57,
  50,
  57,
  52,
  57,
  54,
  57,
  55,
  57,
  57,
  57,
  59,
  57,
  50,
  57,
  57,
  57,
  59,
  57,
  60,
  57,
  50,
  57,
  59,
  57,
  60,
  57,
  62,
  57,
  59,
  57,
  60,
  57,
  59,
  57,
  60,
  57,
  57,
  57,
  59,
  57,
  57,
  57,
  59,
  57,
  55,
  57,
  57,
  57,
  55,
  57,
  57,
  57,
  54,
  57,
  55,
  57,
  54,
  57,
  55,
  57,
  52,
  57,
  54,
  57,
  50,
  52,
  53,
  50,
  54,
  50,
  55,
  50,
  56,
  50,
  57,
  50,
  58,
  50,
  59,
  50,
  60,
  50,
  61,
  50,
  62,
  50,
  63,
  50,
  64,
  50,
  65,
  50,
  66,
  50,
  67,
  59,
  50,
  59,
  67,
  59,
  67,
  59,
  67,
  59,
  50,
  59,
  67,
  59,
  67,
  59,
  67,
  57,
  50,
  57,
  67,
  57,
  67,
  57,
  67,
  57,
  50,
  57,
  67,
  57,
  67,
  57,
  66,
  60,
  50,
  60,
  66,
  60,
  66,
  60,
  66,
  60,
  50,
  60,
  66,
  60,
  66,
  60,
  43,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  67,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
];

/**
 * @fileoverview This file contains the Thread class.
 * @author Alexander Chen alex@chenalexander.com
 * @version 0.1
 */

/**
 * Defines a range for the distance that we can pull long threads
 * perpendicularly from middle point of the thread, in pixels.
 * Essentially, how taut or loose a thread is.
 */
var SLACK_LONG = 10;
var SLACK_SHORT = 10;

/**
 * Defines perpendicular distance between the thread and a cursor
 * to allow it to do an instant grab when mouse is pressed.
 */
var DISTANCE_INSTANT_GRAB = 8;

/**
 * This value adjusts the curvature at the control point
 * where a thread is held. This should be set as a ratio from 0 to 1.
 * A value of 0 creates no curve, resulting in a sharp point
 * and a value of 1 creates a wide arc. Values around 0.5 work best.
 */
var CURVATURE_RATIO = 0.45;

/**
 * Defines a range for the oscillation speed of low note threads by the number
 * of pixels the center point will travel per update call.
 */
var OSCILLATION_SPEED_LOW_NOTES = 1.2;
var OSCILLATION_SPEED_HIGH_NOTES = 3.0;

/**
 * When a user brushes over a thread without grabbing onto it, move the thread
 * this many pixels so that we always show some movement.
 * @type {number}
 * @const
 */
var MINIMUM_AMPLITUDE = 7;

/**
 * Defines a range for the amplitude dampening of low note threads.
 * Every update call, the amplitude is dampened by using this ratio
 * as a multiplier.
 */
var AMPLITUDE_DAMPEN_LOW_NOTES = 0.92;
var AMPLITUDE_DAMPEN_HIGH_NOTES = 0.87;

/**
 * Minimum and maximum volume used when playing a note.
 */
var VOLUME_MIN = 0.0;
var VOLUME_MAX = 0.0;

jQuery("#sound a").click(function (e) {
  e.preventDefault();

  if (jQuery(this).parent().hasClass("activated")) {
    jQuery(this).parent().removeClass("activated");
    VOLUME_MIN = 0.0;
    VOLUME_MAX = 0.0;
  } else {
    jQuery(this).parent().addClass("activated");
    VOLUME_MIN = 0.3;
    VOLUME_MAX = 0.3;
  }
});

/**
 * The farthest left and right that a note can be played.
 */
var PAN_LEFT = -0.3;
var PAN_RIGHT = 0.3;

/**
 * Builds a new Thread, a pluckable string.
 * @class This is the Thread class.
 * @constructor
 * @param {number} ypPm Description
 */
var Thread = function (ypPm, pitchPm, strPm, hexPm, indPm, cvPm) {
  // Initialize point objects.
  this.pt0 = new Point(0, 0);
  this.pt1 = new Point(0, 0);
  // Y position for the thread.
  this.yp0 = this.yp1 = ypPm;
  // set my initial pitch.
  this.pitchInd = pitchPm;
  // Set initial length
  this.len = 0;
  // my permanent midpoint
  this.xMid;
  this.yMid;
  // the position of my swinging pendulum point (midpoint)
  this.xc;
  this.yc;
  // my grabbed point by user
  this.xg;
  this.yg;
  this.xgi;
  this.ygi;
  this.xg1;
  this.yg1;
  this.xg0;
  this.yg0;
  // drawing point
  this.xd;
  this.yd;
  // store permanent dx, dy
  this.dx;
  this.dy;
  // minimum distance to move (px), amplitude, so if you brush it it
  // always shows movement
  this.ampPxMin = 3;
  this.freq;
  this.ampDamp;
  // temporary distance variables
  this.distMax;
  this.distPerp;
  // stores ratio from 0 to 1 where user has grabbed along the string
  this.rGrab;
  this.rHalf;
  // my main angle
  this.ang;
  // my perpendicular angle
  this.angPerp;
  // total length of this thread (when unstretched)
  this.len;
  // temporary variables
  this.dx0;
  this.dy0;
  this.dx1;
  this.dy1;
  this.dist0;
  this.dist1;
  this.dxBez0;
  this.dyBez0;
  this.dxBez1;
  this.dyBez1;
  // my index number
  this.ind = indPm;
  // set stroke weight from parameters
  this.str = strPm;
  // set hex range from parameter
  this.hex = hexPm; // in normal state
  // store as RGB color values too
  this.col = hex2rgb(this.hex);
  // counter for oscillation
  this.t = 0;
  // current amplitude
  this.ampStart;
  this.amp;
  this.ampMax;
  // current stretch strength as ratio
  this.rStrength;
  // is update on
  this.isUpdOn = false;
  // oscillation direction
  this.oscDir;
  // currently grabbed
  this.isGrabbed = false;
  // currently oscillating
  this.isOsc = false;
  // was just dropped
  this.isFirstOsc = false;
  // Is currently resizing
  this.isShifting = false;
  // car that is grabbing me
  this.carGrab = null;

  // link to main canvas
  this.cv = cvPm;
  // initialize
  this.init();
};

/**
 * Initializes the Thread instance.
 */
Thread.prototype.init = function () {
  // link to main machine class
  this.m = suite.machine;
  // update my position to initialize
  this.updPos();
};

/**
 * Set length of thread.
 */
Thread.prototype.setTargetPitch = function (p) {
  // Is it a rest? (-1 pitch)
  if (p == -1) {
    this.pitchInd = -1;
    var lenTarg = 0;
  } else {
    // Set my new pitch right away.
    this.pitchInd = p;
    // My pitch as a ratio from 0 to 1.
    this.rPitch = this.pitchInd / (TOTAL_NOTES - 1);
    // The length we want to ease to to make this pitch work:
    //var lenTarg = lerp(MIN_LENGTH, MAX_LENGTH, 1-this.rPitch);
    var lenTarg = this.m.arrLength[this.pitchInd];
  }
  if (lenTarg != this.len) this.easeToLength(lenTarg);
};

/**
 * Set length of thread.
 */
Thread.prototype.setLength = function (l) {
  this.len = l;
  // update position
  this.updPos();
};

/**
 * Ease to new target length.
 */
Thread.prototype.easeToLength = function (l) {
  this.isShifting = true;
  this.lenTarg = l;
};

/**
 * Update while thread is shifting size.
 */
Thread.prototype.updShifting = function () {
  var ease = 0.2;
  var dl = (this.lenTarg - this.len) * ease;
  // Already there?
  if (Math.abs(dl) < 1) {
    // Set it and stop updating.
    this.setLength(this.lenTarg);
    this.isShifting = false;
  } else {
    this.setLength(this.len + dl);
  }
};

/**
 * Update the start and end positions.
 */
Thread.prototype.updPos = function () {
  // set new x positions
  this.xp0 = -this.len / 2;
  this.xp1 = this.len / 2;

  // Update the point objects for the endpoints.
  this.pt0.setX(this.xp0);
  this.pt0.setY(this.yp0);
  this.pt1.setX(this.xp1);
  this.pt1.setY(this.yp1);
  //
  this.dx = this.xp1 - this.xp0;
  this.dy = this.yp1 - this.yp0;
  // store midpoint
  this.xMid = this.xp0 + this.dx * 0.5;
  this.yMid = this.yp0 + this.dy * 0.5;
  // store angle
  this.ang = Math.atan2(this.dy, this.dx);
  //
  this.angPerp = Math.PI / 2 - this.ang;
  // set new length
  // this.len = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
  // initially set pendulum to midpoint
  this.xc = this.xMid;
  this.yc = this.yMid;
  // Store max distance we can pull from middle of the thread perpendicularly,
  // i.e. looseness of the thread.
  this.distMax = lerp(
    SLACK_SHORT,
    SLACK_LONG,
    (this.len - MIN_LENGTH) / (MAX_LENGTH - MIN_LENGTH)
  );
  // set my oscillation frequency
  this.freq = lerp(
    OSCILLATION_SPEED_LOW_NOTES,
    OSCILLATION_SPEED_HIGH_NOTES,
    this.rPitch
  );
  this.ampDamp = lerp(
    AMPLITUDE_DAMPEN_LOW_NOTES,
    AMPLITUDE_DAMPEN_HIGH_NOTES,
    this.rPitch
  );
  // my maximum amplitude
  this.ampMax = this.distMax;
  // store the sin and cos of my angle and perpendicular angle
  // so that we're not recalculating it every frame
  this.sinAng = Math.sin(this.ang);
  this.cosAng = Math.cos(this.ang);
  this.sinPerp = Math.sin(this.angPerp);
  this.cosPerp = Math.cos(this.angPerp);
};

/**
 * Redraw my thread on the canvas.
 */
Thread.prototype.redraw = function () {
  if (this.len == 0) return;

  // current origin point
  this.xo = this.m.xo;
  this.yo = this.m.yo;

  // weird bug - the first time we run it with the first thread, it breaks
  if (isNaN(this.xp1)) {
    return;
  }

  this.cv.beginPath();
  this.cv.lineCap = "round";
  this.cv.strokeStyle = this.hex;
  this.cv.lineWidth = this.str;

  // grabbed mode (or on the first osc after being dropped)
  if (this.isGrabbed || this.isFirstOsc) {
    this.xd = this.xg;
    this.yd = this.yg;
    // oscillating freely mode
  } else {
    this.xd = this.xc;
    this.yd = this.yc;
  }

  if (isNaN(this.xd)) {
    return;
  }

  this.dx0 = this.xd - this.xp0;
  this.dy0 = this.yd - this.yp0;
  this.dx1 = this.xp1 - this.xd;
  this.dy1 = this.yp1 - this.yd;
  // distance
  this.dist0 = Math.sqrt(this.dx0 * this.dx0 + this.dy0 * this.dy0);
  this.dist1 = Math.sqrt(this.dx1 * this.dx1 + this.dy1 * this.dy1);
  // move to the center pendulum point
  this.dxBez0 = CURVATURE_RATIO * this.dist0 * this.cosAng;
  this.dyBez0 = CURVATURE_RATIO * this.dist0 * this.sinAng;
  // move to the center pendulum point
  this.dxBez1 = CURVATURE_RATIO * this.dist1 * this.cosAng;
  this.dyBez1 = CURVATURE_RATIO * this.dist1 * this.sinAng;
  // move to start point
  this.cv.moveTo(this.xp0 + this.xo, this.yp0 + this.yo);
  // Draw bezier curve
  this.cv.bezierCurveTo(
    this.xd - this.dxBez0 + this.xo,
    this.yd - this.dyBez0 + this.yo,
    this.xd + this.dxBez1 + this.xo,
    this.yd + this.dyBez1 + this.yo,
    this.xp1 + this.xo,
    this.yp1 + this.yo
  );
  // close path
  this.cv.stroke();
  this.cv.closePath();
};

/**
 * Update function run every frame.
 * Triggers other update functions.
 */
Thread.prototype.upd = function () {
  // Is thread currently shifting size?
  if (this.isShifting) {
    this.updShifting();
  }
  // is thread currently grabbed
  if (this.isGrabbed) {
    this.updGrab();
    // is thread currently oscillating
  } else if (this.isOsc) {
    this.updOsc();
  }
};

/**
 * Update this thread when I am in oscillation
 * mode after being plucked.
 */
Thread.prototype.updOsc = function () {
  // ease it back to the zero line first
  if (this.isFirstOsc) {
    var ease = 0.8;
    var dxg = this.xg1 - this.xg;
    var dyg = this.yg1 - this.yg;
    //
    this.xg += dxg * ease;
    this.yg += dyg * ease;
    // have we arrived?
    if (Math.abs(dxg) < 2 && Math.abs(dyg) < 2) {
      // initialize
      this.t = 0;
      this.oscDir = 1;
      this.isFirstOsc = false;
      // which direction it has been going in
      var sx0 = sign(dxg);
      var sx1 = sign(this.sinAng);
      // reverse the initial oscillation direction if needed
      if (sx0 != sx1) {
        this.oscDir *= -1;
      }
    }
  } else {
    // increment counter
    this.t += this.freq * this.oscDir;
    // make c oscillate between 0 and 1 with sin
    var c = Math.sin(this.t);
    // dampen the amplitude
    this.amp *= this.ampDamp;
    //
    this.xc = this.xMid + c * this.sinAng * this.amp;
    this.yc = this.yMid - c * this.cosAng * this.amp;
    // 3/10 - lowered limit so that colors continue easing out
    // if amplitude is below mimum, cut it
    if (this.amp <= 0.15) {
      this.amp = 0;
      this.isOsc = false;
      // every time a string stops oscillating,
      // just tally to see if anything is moving
      this.m.checkMoving();
    }
  }
};

/**
 * Update mode while I am being held/grabbed by the
 * the user.
 */
Thread.prototype.updGrab = function () {
  // get current mouse position
  // grabbed by car?
  if (this.carGrab != null) {
    var xu = this.carGrab.xp1;
    var yu = this.carGrab.yp1;
    // else grabbed by user
  } else {
    var xu = this.m.getUserX();
    var yu = this.m.getUserY();
  }

  // how far away is it from the line
  var dxu = xu - this.xp0;
  var dyu = yu - this.yp0;
  // angle
  var ang0 = Math.atan2(dyu, dxu);
  var ang1 = this.ang - ang0;
  // direct distance
  var hyp = Math.sqrt(dxu * dxu + dyu * dyu);
  // perpendicular distance
  this.distPerp = hyp * Math.sin(ang1);
  // distance parallel along the line
  var distPara = hyp * Math.cos(ang1);
  // how far as a ratio from 0 to 1 are we on the line
  this.rGrab = lim(distPara / this.len, 0, 1);
  // normalize it to increase to 1 at the halfway point
  if (this.rGrab <= 0.5) {
    this.rHalf = this.rGrab / 0.5;
  } else {
    this.rHalf = 1 - (this.rGrab - 0.5) / 0.5;
  }
  // what distance can we pull the string at this point?
  var distMaxAllow = this.distMax * this.rHalf;
  // set the current stretch strength
  this.rStrength = lim(Math.abs(this.distPerp) / this.distMax, 0, 1);

  // has the user's point pulled too far?
  if (Math.abs(this.distPerp) > distMaxAllow) {
    this.drop();
  } else {
    // that grabbed point is ok, allow it
    this.xg = xu;
    this.yg = yu;
  }
};

/**
 * When user brushes over string in one frame and
 * does not grab it, pluck is run. Also used for auto-pluck by
 * keystrokes.
 * @param {number} xp is x position where user intersected Thread.
 * @param {number} yp is y position where user intersected Thread.
 * @param {boolean} isNub: true if doing pluck by a nub.
 */
Thread.prototype.pluck = function (xp, yp, isNub, car) {
  // store as initial position
  this.xgi = this.xg = xp;
  this.ygi = this.yg = yp;
  // user's current mouse position
  var xu = this.m.getUserX();
  var yu = this.m.getUserY();
  // how far away is it from the line
  var dxu = xu - this.xp0;
  var dyu = yu - this.yp0;
  // use our current xg and yg, that's where the user
  // intersected the string
  var dxg = this.xgi - this.xp0;
  var dyg = this.ygi - this.yp0;
  var hyp = Math.sqrt(dxu * dxu + dyu * dyu);
  // as ratio 0 to 1
  this.rGrab = lim(hyp / this.len, 0, 1);
  // normalize it to increase to 1 at the halfway point
  if (this.rGrab <= 0.5) {
    this.rHalf = this.rGrab / 0.5;
  } else {
    this.rHalf = 1 - (this.rGrab - 0.5) / 0.5;
  }
  var distMaxAllow = this.distMax * this.rHalf;
  // Base on user's speed if it was plucked normally by mouse,
  // otherwise use max speed
  var spdAvg = isNub ? 1 : this.m.getSpdAvg();
  // how far do we want it to pull?
  this.distPerp = (1 - spdAvg) * distMaxAllow;
  // set new strength
  if (isNub) {
    this.rStrength = 1;
  } else {
    this.rStrength = lim(Math.abs(this.distPerp) / this.distMax, 0, 1);
  }

  // less than minimum? (always vibrate string a little bit)
  if (this.distPerp < this.ampPxMin) this.distPerp = this.ampPxMin;
  // set it
  this.xg = this.xgi + this.distPerp * this.cosPerp;
  this.yg = this.ygi + this.distPerp * this.sinPerp;
  // ------------------
  // reset me to the center point
  this.xc = this.xMid;
  this.yc = this.yMid;
  // already oscillating?
  if (this.isOsc) {
    // already oscillating - boost the oscillation strength just a bit
    this.rStrength = lim(this.rStrength * 0.5 + this.amp / this.ampMax, 0, 1);
    // set new amplitude
    this.amp = this.rStrength * this.ampMax;
    // not oscillating - start oscillating now
  } else {
    // store current amplitude based on strength
    this.amp = this.rStrength * this.ampMax;
    // start oscillating
    this.startOsc();
  }
  var rPan = this.m.xAsRatio(xp);
  // play note
  this.playNote(this.rStrength, rPan, false);
};

/**
 * User grabs this thread to hold onto it.
 * @param {number} xp is x position where user grabbed Thread.
 * @param {number} yp is y position where user grabbed Thread.
 */
Thread.prototype.grab = function (xp, yp, isNub, car) {
  if (!isNub) {
    //
    this.carGrab = null;
  } else {
    // store car that is grabbing me, and link me to the car
    this.carGrab = car;
    this.carGrab.thrGrab = this;
    // grabbed by car
  }
  // store as initial position
  this.xgi = this.xg = xp;
  this.ygi = this.yg = yp;
  this.isGrabbed = true;
  //
  this.m.ctGrab++;
  // update once now
  this.updGrab();
};

/**
 * User is currently grabbing and thread and releases it, triggering
 * drop() function.
 */
Thread.prototype.drop = function () {
  this.m.ctGrab--;
  //
  this.isGrabbed = false;
  // reset me
  this.xc = this.xMid;
  this.yc = this.yMid;
  // store current amplitude based on strength
  this.amp = this.rStrength * this.ampMax;
  // play note - is it by a car?
  if (this.carGrab != null) {
    //var vol = lerp(VOLUME_MIN, VOLUME_MAX, this.rStrength);
    this.carGrab.thrGrab = null;
    this.carGrab = null;
    // else use normal user volume limits
  } else {
    //var vol = lerp(VOLUME_MIN, VOLUME_MAX, this.rStrength);
    //var pan = this.m.xAsRatio(this.m.getUserX());
  }
  // set panning ratio -1 to 1
  var rPan = this.m.xAsRatio(this.xg + this.xo);

  // play note - use strength for volume, and user's cursor as
  // panning position
  this.playNote(this.rStrength, rPan);
  // start oscillation
  this.startOsc();
};

/**
 * Thread starts oscillating after being released.
 */
Thread.prototype.startOsc = function () {
  // where does the grabbed point want to return to
  this.xg1 = this.xp0 + this.rGrab * this.dx;
  this.yg1 = this.yp0 + this.rGrab * this.dy;
  // store start position
  this.xg0 = this.xg;
  this.yg0 = this.yg;
  // counter
  this.t = 0;
  // we are on our first cycle of oscillation
  this.isFirstOsc = this.isOsc = true;
};

/**
 * Play my note.
 * The member variables vol0 and vol1 to define actual volume range.
 * The member variables pan0 and pan1 to define actual panning range.
 * @param {number} rVol is a ratio 0 to 1 for volume. Uses
 * @param {number} rPan is a ratio -1 to 1 for left/right panning
 */
Thread.prototype.playNote = function (rVol, rPan) {
  // If i'm currently empty, don't play any note
  if (this.pitchInd == -1) return;
  var pre = this.pitchInd < 10 ? "0" : "";
  // make sure sound has been loaded
  // if (!suite.soundReady) return;
  suite.playSound(
    this.pitchInd,
    VOLUME_MIN + rVol * (VOLUME_MAX - VOLUME_MIN),
    PAN_LEFT + rPan * (PAN_RIGHT - PAN_LEFT)
  );
};

/**
 * Define constants.
 */

// Set radius of wheel and other constants.
var WHEEL_RADIUS = 172;
var WHEEL_RADIUS_SQUARED = Math.pow(WHEEL_RADIUS, 2);
var WHEEL_CIRCUMFERENCE = Math.PI * WHEEL_RADIUS_SQUARED;
// Length of a line segment drawn through quarter arc of circle.
var WHEEL_QUARTER_SEG = Math.sqrt(2 * WHEEL_RADIUS_SQUARED);

// How many total nubs in the machine.
var NUBS = 4;
// Which thread do we want to use for the preloader (index number)
var THREAD_LOADER = 0;
// Minimimum amount of time between loading sounds to wait to help preload animation,
// while strings are still building.
var TIME_BETWEEN_LOAD = 0.25;
// Around how long do we want the overall build sequence to last
var LOAD_TIME_OVERALL = 12.5;
// Margin around the bounding clearRect calls.
var CLEAR_RECT_MARG = 50;
// How much vertical space does the stack of threads take up.
var HEIGHT_ALL_THREADS = WHEEL_QUARTER_SEG;
// Below this framerate, we assume it's in a background tab threshhold.
var FPS_BACKGROUND = 2;

/**
 * Builds a new Machine class, which runs everything.
 * @class This is the Machine class.
 * @constructor
 * @param {object} cvPm the Canvas context to draw in.
 */
var Machine = function (cvPm) {
  // store my canvas
  this.cv = cvPm;
  // stores whether mouse is moving
  this.isMouseMoving = false;
  // array of threads
  this.arrThreads = new Array();
  // Array of thread lengths for each of the notes
  this.arrLength = new Array();
  // Array of nubs
  this.arrNubs = new Array(4);
  // Store array of starting pitches for the threads
  this.arrPitchStart = new Array(TOTAL_THREADS);
  // boolean whether mouse is currently pressed
  this.isMouseDown = false;
  // min max speed as a ratio
  this.rSpd = 0;
  // average speed over the past few frames
  this.rSpdAvg = 0;
  // how many frames to make average
  this.fAvg = 5;
  //var this.bps = this.bpm/60;
  this.setTempo(BPM_NORM);
  // user speed low limit where we can grab and hold string
  // (as ratio 0 to 1)
  this.rSpdGrab = 0.4;
  // tracks mouse position
  this.xp0;
  this.yp0;
  this.xp1;
  this.yp1;
  // as point objects
  this.pt0 = new Point();
  this.pt1 = new Point();
  // stores whether this is the first time running update
  this.isFirstRun = true;
  this.wasResized = false;
  // Is user currently holding a nub?
  this.isHoldingNub = false;
  // Stores what nub the user is rolled over
  this.nubOver = null;
  // Stores which index the first note of 8 is set to.
  this.indGroup = 0;
  // Stores how many threads are currently grabbed by user.
  this.ctGrab = 0;
  // Limit how many threads I can pluck in one frame
  this.pluckMax = 2;
  // Which thread are we currently on for preloader
  this.indThreadLoader = 0;
  // Are we in preload mode
  this.isIntro = true;
  // Is the intro done and we can begin song whenever we're ready?
  this.isIntroDone = false;
  // Stores which note we are in terms of the song
  this.noteSongRdPrev = 0;
  // Are all strings at their final position?
  this.threadsInPlace = false;
  // Am I currently in the background tab?
  this.isInBackground = false;
  // Stores the minimum size of our bounding box just around the threads.
  this.xbLimitMin = -MAX_LENGTH * 0.5;
  this.xbLimitMax = MAX_LENGTH * 0.5;
  this.ybLimitMin = -HEIGHT_ALL_THREADS * 0.5;
  this.ybLimitMax = HEIGHT_ALL_THREADS * 0.5;
  // Stores the bounding box limits for our clearRect refresh calls.
  this.xbMin = this.xbLimitMin;
  this.xbMax = this.xbLimitMax;
  this.ybMin = this.ybLimitMin;
  this.ybMax = this.ybLimitMax;

  this.init();
};

/**
 * Initialize machine.
 */
Machine.prototype.init = function () {
  this.elmLoader = document.getElementById("loader");
};

/**
 * Builds the Thread objects
 */
Machine.prototype.build = function () {
  this.setOrigin();
  // Build an array of the lengths for each note.
  var lenCurr = MAX_LENGTH;
  for (var i = 0; i < TOTAL_NOTES; i++) {
    this.arrLength[i] = lenCurr;
    lenCurr *= HALF_STEP_MULTIPLIER;
  }

  var len, str, hex, pitch;
  // vertical distance between threads
  var dy = WHEEL_QUARTER_SEG / TOTAL_THREADS;
  var yp = (TOTAL_THREADS / 2) * dy - 0.5 * dy;
  // go through all threads and draw them
  for (var i = 0; i < TOTAL_THREADS; i++) {
    // Store the starting pitch for the threads
    this.arrPitchStart[i] = suite.arrMidiMap[SONG_DATA_ARRAY[i]];
    hex = "#FFFFFF";
    str = 3;
    var pitch = -1;
    var thr = new Thread(yp, pitch, str, hex, i, this.cv);
    yp -= dy;
    this.arrThreads.push(thr);
  }
  // Build wheels - x, y, index, canvas
  this.wheel0 = new Wheel(WHEEL_RADIUS, 0, 0, this.cv);
  this.wheel1 = new Wheel(-WHEEL_RADIUS, 0, 1, this.cv);
  // Build nubs for them
  this.arrNubs[0] = this.wheel0.nub0 = new Nub(
    0,
    0,
    suite.machine,
    this.wheel0,
    this.cv
  );
  this.arrNubs[1] = this.wheel0.nub1 = new Nub(
    1,
    1,
    suite.machine,
    this.wheel0,
    this.cv
  );
  this.arrNubs[2] = this.wheel1.nub0 = new Nub(
    0,
    2,
    suite.machine,
    this.wheel1,
    this.cv
  );
  this.arrNubs[3] = this.wheel1.nub1 = new Nub(
    1,
    3,
    suite.machine,
    this.wheel1,
    this.cv
  );
  // composite mode
  this.cv.globalCompositeOperation = "lighter";
  // Set the first nub as the loader nub
  this.arrNubs[0].enter();
};

/**
 * Start loading sequence
 */
Machine.prototype.beginLoading = function () {
  // initialize timer
  this.tFrame0 = this.tSong0 = this.tNotes0 = this.tLoadPrev = this.tLoading0 = this.t0 =
    new Date().getTime() / 1000;
  this.ctFrame = 0;
  // store current mouse pos
  this.xp0 = this.getUserX();
  this.yp0 = this.getUserY();
};

/**
 * Exit loading sequence.
 */
Machine.prototype.exitLoading = function () {
  this.isIntro = false;
  // Release nubs from loading mode.
  for (var i = 0; i < this.arrNubs.length; i++) this.arrNubs[i].exitLoader();
  //var d = new Date(); this.tSong0 = this.tNotes0 = this.t0 = d.getTime()/1000;
  // update all the threads once now
  this.updThreads();
};

/**
 * When mouse button is pushed.
 */
Machine.prototype.mouseDown = function () {
  this.isMouseDown = true;
};

/**
 * When mouse button is released.
 */
Machine.prototype.mouseUp = function () {
  // stop updating
  this.isMouseDown = false;
};

/**
 * Set threads to batch of 8 notes starting at index n.
 */
Machine.prototype.setGroup = function (n) {
  this.indGroup = n;
  for (var i = 0; i < this.arrThreads.length; i++) {
    var note = SONG_DATA_ARRAY[this.indGroup + i];
    // is it a rest?
    if (note == -1) {
      pitch = -1;
    } else {
      // what pitch do we want to make it?
      pitch = suite.arrMidiMap[note];
    }
    this.arrThreads[i].setTargetPitch(pitch);
  }
};

/**
 * Set current tempo.
 */
Machine.prototype.setTempo = function (t) {
  this.bpm = t;
  this.bps = t / 60;
};

/**
 * Returns x position of the mouse in terms of my canvas
 * coordinate space.
 * @return {number} x position of the mouse.
 */
Machine.prototype.getUserX = function () {
  return mouseX - this.xo;
};

/**
 * Returns y position of the mouse in terms of my canvas
 * coordinate space.
 * @return {number} y position of the mouse.
 */
Machine.prototype.getUserY = function () {
  return mouseY - this.yo;
};

/**
 * Converts an x position in our Canvas coordinates to
 * a ratio of -1 to 1, where -1 is all the way at left,
 * and 1 is right, and 0.5 is dead center.
 * @param {number} xp is the x position to convert.
 */
Machine.prototype.xAsRatio = function (xp) {
  xp = lim(xp, 0, this.width);
  return xp / this.width;
};

/**
 * Machine update that is run every frame.
 */
Machine.prototype.upd = function () {
  // At beginning of each update loop, set the bounding box to
  // at least refresh the threads.
  this.xbMin = this.xbLimitMin;
  this.xbMax = this.xbLimitMax;
  this.ybMin = this.ybLimitMin;
  this.ybMax = this.ybLimitMax;
  // Are we still loading?
  if (SHOW_FRAMERATE) this.updFramerate(); // Show framerate
  if (this.isIntro) this.updLoading(); // Show loading number
  // Update timing.
  if (this.isIntro) {
    this.updTime();
  } else {
    this.updTime();
  }
  // update position
  this.updPos();
  // is mouse pressed?
  if (!this.isMouseDown) {
    this.updMouseUp();
  }
  // composite mode
  if (this.wasResized) {
    this.wasResized = false;
    this.cv.globalCompositeOperation = "lighter";
  }
  // clear enter canvas
  // this.cv.clearRect(0, 0, this.width, this.height);

  // update all the threads
  //this.updThreads();
  // update the wheels
  this.updWheels();

  this.cv.clearRect(
    this.xo + this.xbMin - CLEAR_RECT_MARG,
    this.yo + this.ybMin - CLEAR_RECT_MARG,
    this.xbMax - this.xbMin + CLEAR_RECT_MARG * 2,
    this.ybMax - this.ybMin + CLEAR_RECT_MARG * 2
  );

  /*
    this.cv.fillStyle = "rgba(255,255,255,0.3)";
    this.cv.fillRect(
      this.xo+this.xbMin-CLEAR_RECT_MARG,
      this.yo+this.ybMin-CLEAR_RECT_MARG,
      this.xbMax-this.xbMin+CLEAR_RECT_MARG*2,
      this.ybMax-this.ybMin+CLEAR_RECT_MARG*2
    );
    */
  //this.updThreads();
  this.updateAndRedrawThreads();
  this.redrawNubs();
};

/**
 * Update timing.
 */
Machine.prototype.updTime = function () {
  // how much time has elapsed since last update?
  this.t1 = new Date().getTime() / 1000;
  this.elapFrame = this.t1 - this.t0;
  this.t0 = this.t1;

  var fps = 1 / this.elapFrame; // check if we're probably in tab in the background
  if (fps <= FPS_BACKGROUND) {
    if (!this.isInBackground) {
      this.switchBackgroundMode(1);
      this.isInBackground = true;
    }
  } else {
    if (this.isInBackground) {
      this.switchBackgroundMode(0);
      this.isInBackground = false;
    }
  }

  // Where are we in terms of the song beats?
  this.elapSong = this.t1 - this.tSong0;
  this.beatSong = this.bps * this.elapSong;
  this.noteSong = this.beatSong * NOTE_UNIT;
  this.noteSongRd = Math.floor(this.noteSong);

  // If we're in the intro mode
  if (this.isIntro) {
    // Are we at a new note?
    if (this.noteSongRd != this.noteSongRdPrev) {
      // Are we ready to move on now?
      if (this.isIntroDone) {
        // Did we just skip over a clean break where we can start the song?
        if (
          this.noteSongRdPrev < this.nextNoteBreak &&
          this.noteSongRd >= this.nextNoteBreak
        ) {
          // Bump
          //var d = new Date(); this.tSong0 = this.tNotes0 = this.t0 = d.getTime()/1000;
          // Set the time to where it would have been... to make it seamless.
          //this.tSong0 =
          var beatSingle = this.beatSong % 1;
          var elapFudge = beatSingle / this.bps;
          // Now back-date it.
          this.tSong0 = this.tNotes0 = this.t1 - elapFudge;
          this.exitLoading();
        }
      }
      this.noteSongRdPrev = this.noteSongRd;
    }

    // Else in normal mode
  } else {
    if (this.noteSong > this.indGroup + TOTAL_THREADS) {
      this.tNotes0 = this.t1;
      // Increment to next group.
      var nextGroup = this.indGroup + TOTAL_THREADS;
      // Have we reached the end of the song?
      if (nextGroup >= TOTAL_NOTES_IN_SONG) {
        nextGroup = 0;
        // Reset the song counter point
        this.tSong0 = this.t1;
      }
      this.setGroup(nextGroup);
    }
  }

  // Where is the next clean break where we can start the song.
  // Should round to groups of 32 (or 16?)
  this.nextNoteBreak = this.noteSongRd + (32 - (this.noteSongRd % 32));
};

/**
 * Goes through all Threads and updates and redraws them
 */
Machine.prototype.updWheels = function () {
  // set left wheel rotation
  var rot;
  //
  this.wheel0.setRot(
    (MATH_PI * (0.25 + ((this.beatSong % 16) / 16) * 2)) % (2 * MATH_PI)
  );
  this.wheel1.setRot(
    (MATH_PI * (0.25 - ((this.beatSong % 16) / 16) * 2)) % (2 * MATH_PI)
  );
  //
  this.wheel0.upd();
  this.wheel1.upd();
};

/**
 * Update timing.
 */
Machine.prototype.switchBackgroundMode = function (n) {
  switch (n) {
    // turn on background mode
    case 1:
      break;
    // turn off background mode
    case 0:
      for (var i = 0; i < 4; i++) this.arrNubs[i].returnFromBackground();
      break;
    default:
      break;
  }
};

/**
 * Redraw wheels.
 */
Machine.prototype.redrawNubs = function () {
  this.wheel0.nub0.redraw();
  this.wheel0.nub1.redraw();
  this.wheel1.nub0.redraw();
  this.wheel1.nub1.redraw();
};

/**
 * Goes through all Threads and updates and redraws them
 */
Machine.prototype.updThreads = function () {
  for (var i = 0; i < this.arrThreads.length; i++) {
    this.arrThreads[i].upd();
  }
};

/**
 * Goes through all Threads and updates and redraws them
 */
Machine.prototype.redrawThreads = function () {
  for (var i = 0; i < this.arrThreads.length; i++) {
    this.arrThreads[i].redraw();
  }
};

/**
 * Goes through all Threads and updates and redraws them
 */
Machine.prototype.updateAndRedrawThreads = function () {
  for (var i = 0; i < this.arrThreads.length; i++) {
    this.arrThreads[i].upd();
    this.arrThreads[i].redraw();
  }
};

/**
 * Update status text.
 */
Machine.prototype.updLoading = function () {
  var str;
  // are we loading audio?
  if (!suite.soundReady) {
    var perc = Math.round((suite.indNoteLd / TOTAL_NOTES) * 100);
    //str = "Loading sound ("+ perc + "%)";
    if (SHOW_FRAMERATE) {
      //this.elmLoader.innerHTML += "<span class=\"loading\">" + str + "</span>";
    } else {
      //this.elmLoader.innerHTML = "<span class=\"loading\">" + str + "</span>";
    }
  }
  // How much time since we last updated the load animation?
  this.tLoadCurr = new Date().getTime() / 1000;
  var elap = this.tLoadCurr - this.tLoadPrev;

  // How long has the loading sequence lasted?
  this.rLoad = (this.tLoadCurr - this.tLoading0) / LOAD_TIME_OVERALL;
  if (this.rLoad >= 1) this.rLoad = 1;
  // Time to go?
  if (elap > TIME_BETWEEN_LOAD) {
    this.tLoadPrev = this.tLoadCurr;
    this.incrLoad();
  }
};

/**
 * Update framerate counter
 */
Machine.prototype.updFramerate = function () {
  this.tFrame1 = new Date().getTime() / 1000;
  var elap = this.tFrame1 - this.tFrame0;
  this.tFrame0 = this.tFrame1;

  // are we loading audio?
  this.ctFrame++;
  if (this.ctFrame % 5 == 0) {
    this.numFrame = Math.round(100 / elap) / 100;
  }
  this.elmLoader.innerHTML =
    '<span class="loading">' + this.numFrame + "</span> &nbsp; ";
};

/**
 * Go to next step in loading thread animation.
 */
Machine.prototype.incrLoad = function () {
  // Release another nub?
  var nub;
  if (this.rLoad > 0.15) {
    nub = this.arrNubs[2];
    if (!nub.hasEntered) nub.enter();
    nub = this.arrNubs[0];
    if (!nub.hasEntered) nub.enter(); // Double check that the first one has entered, it skipped once
  }
  if (this.rLoad > 0.85) {
    nub = this.arrNubs[1];
    if (!nub.hasEntered) nub.enter();
  }
  if (this.rLoad > 0.97) {
    nub = this.arrNubs[3];
    if (!nub.hasEntered) nub.enter();
  }

  // How many threads to currently show?
  var rCut0 = 0.4;
  var rCut1 = 0.8;
  var rShow;
  if (this.rLoad < rCut0) {
    rShow = 0; // Only show one thread for a while.
  } else {
    rShow = (this.rLoad - rCut0) / (rCut1 - rCut0);
    if (rShow > 1) rShow = 1;
  }
  var showThreads = rShow * TOTAL_THREADS;
  // Start at a random place.
  var ind = Math.floor(Math.random() * 0.999 * showThreads);
  var pitchStart, pitchTarg, thr;
  var ctThreadsInPlace = 0;
  // Cycle through the threads.
  for (var i = 0; i < TOTAL_THREADS; i++) {
    if (i > showThreads) break;
    pitchStart = this.arrPitchStart[ind];
    thr = this.arrThreads[ind];
    // Is that thread already at its target?
    if (thr.pitchInd == pitchStart) {
      ind = (ind + 1) % TOTAL_THREADS; // Just continue.
      ctThreadsInPlace++;
    } else {
      // Want to increment thread to its next note. Have we loaded that note?
      var incr;
      if (showThreads == 0) {
        incr = 1;
      } else {
        incr = 1 + Math.round(Math.random() * 2);
      }
      // Have notes slowly ease up as time progresses
      off = Math.floor(lerp(-3, 0, this.rLoad));
      pitchTarg = thr.pitchInd + incr + off;
      if (pitchTarg < 0) pitchTarg = 0;
      // Make sure it's not higher than what we want
      if (pitchTarg > pitchStart) pitchTarg = pitchStart;
      if (suite.indNoteLd > 0 && suite.indNoteLd - 1 >= pitchTarg) {
        thr.setTargetPitch(pitchTarg);
        break;
      }
    }
  }
  // Did we find a thread to change?
  if (ctThreadsInPlace == TOTAL_THREADS && !this.threadsInPlace)
    this.threadsInPlace = true;

  // If all threads are in place, and sound is loaded, we now begin.
  if (
    this.threadsInPlace &&
    suite.soundReady &&
    this.rLoad >= 1 &&
    !this.isIntroDone
  ) {
    console.log("isIntroDone true!");
    this.isIntroDone = true;
  }
};

/**
 * Goes through all Threads and counts up how many are grabbed
 * or oscillating, so we know whether we need to redraw.
 */
Machine.prototype.checkMoving = function () {
  //var ctGrab = 0;
  var ctOsc = 0;
  for (var i = 0; i < this.arrThreads.length; i++) {
    //if (this.arrThreads[i].isGrabbed) ctGrab++;
    if (this.arrThreads[i].isOsc) ctOsc++;
  }
};

/**
 * Returns user's mouse speed as ratio 0 to 1, normalized to
 * the bounds of spdMin and spdMax. This is set in update loop.
 * @return {number} user's mouse speed as ratio 0 to 1
 */
Machine.prototype.getSpd = function () {
  return this.rSpd;
};

/**
 * Returns user's mouse speed as ratio 0 to 1, normalized to
 * the bounds of spdMin and spdMax. This is set in update loop.
 * Difference is it is averaged every few frames.
 * @return {number} user's mouse speed as ratio 0 to 1
 */
Machine.prototype.getSpdAvg = function () {
  return this.rSpdAvg;
};

/**
 * Update loop run every frame, triggered by #upd.
 */
Machine.prototype.updPos = function () {
  // get new position
  this.xp1 = this.getUserX();
  this.yp1 = this.getUserY();
  // update point objects
  this.pt0.x = this.xp0;
  this.pt0.y = this.yp0;
  this.pt1.x = this.xp1;
  this.pt1.y = this.yp1;
  //
  this.dx = this.xp1 - this.xp0;
  this.dy = this.yp1 - this.yp0;
  //
  this.dist = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
  // is the mouse moving?
  this.isMouseMoving = this.dist > 0.2;
  // current speed - pixels per second
  this.spd = this.dist / this.elapFrame;
  // normalize it from 0 to 1
  this.rSpd = lim(
    (this.spd - MOUSE_SPEED_MIN) / (MOUSE_SPEED_MAX - MOUSE_SPEED_MIN),
    0,
    1
  );
  // get average
  this.rSpdAvg =
    (this.rSpdAvg * (this.fAvg - 1)) / this.fAvg + this.rSpd * (1 / this.fAvg);
  // store previous position
  this.xp0 = this.xp1;
  this.yp0 = this.yp1;
};

/**
 * Update mode while mouse is up.
 */
Machine.prototype.updMouseUp = function () {
  // Are we already rolled over one?
  if (this.nubOver != null && !this.isHoldingNub) {
    // Make sure we're still over that one
    if (this.nubOver.checkMouseOver()) {
      return; // We're still over it, ignore others
    } else {
      this.nubOver.rollOut(); // We rolled out of it.
      this.nubOver = null;
    }
  }

  // Check if we're rolled over any nubs
  for (var i = 0; i < 4; i++) {
    if (this.arrNubs[i].checkMouseOver()) {
      this.nubOver = this.arrNubs[i];
      this.nubOver.rollOver();
      break; // Don't check anymore, only roll over one at a time
    }
  }
};

/**
 * Triggered when mouse is pressed.
 */
Machine.prototype.mouseDown = function () {
  this.isMouseDown = true;
  // Are we over a nub?
  if (this.nubOver != null) {
    this.nubOver.grab(); // grab it
    this.isHoldingNub = true; // Remember we're holding a nub
  }
};

/**
 * Triggered when mouse is released.
 */
Machine.prototype.mouseUp = function () {
  this.isMouseDown = false;
  // We we holding a nub?
  if (this.isHoldingNub) {
    this.nubOver.drop();
    this.isHoldingNub = false;
  }
};

/**
 * Drop all strings that are currently grabbed.
 */
Machine.prototype.dropAll = function () {
  for (var i = 0; i < this.arrThreads.length; i++) {
    if (this.arrThreads[i].isGrabbed) this.arrThreads[i].drop();
  }
};

/**
 * Done loading.
 */
Machine.prototype.doneLoading = function () {
  // hide the "loading audio text"
  if (!SHOW_FRAMERATE) this.elmLoader.style.display = "none";
};

/**
 * Triggered everytime window is resized.
 */
Machine.prototype.checkBoxLimit = function (x, y) {
  // Is this beyond the limit of the current bounding box?
  if (x < this.xbMin) this.xbMin = x;
  else if (x > this.xbMax) this.xbMax = x;
  //
  if (y < this.ybMin) this.ybMin = y;
  else if (y > this.ybMax) this.ybMax = y;
};

/**
 * Triggered everytime window is resized.
 */
Machine.prototype.rsize = function () {
  this.wasResized = true;
  // make the canvas objects match window size
  this.width = suite.canvasEl.width = window.innerWidth;
  this.height = suite.canvasEl.height = window.innerHeight;
  // move the loader box
  this.elmLoader.style.left = "20px";
  this.elmLoader.style.top = this.height - 28 + "px";
  // move the about ? box
  // update the origin
  this.setOrigin();
};

/**
 * Updates the origin point.
 */
Machine.prototype.setOrigin = function () {
  this.xo = Math.round(this.width / 2);
  this.yo = Math.round(this.height / 2);
};

/**
 * @fileoverview This file contains the Wheel class.
 * @author Alexander Chen alex@chenalexander.com
 * @version 0.1
 */

/**
 * Builds a new Wheel.
 * @class This is the Wheel class.
 * @constructor
 * @param
 */
var Wheel = function (xpPm, ypPm, indPm, cvPm) {
  // my index number (0 or 1)
  this.ind = indPm;
  // set my center position
  this.xp = xpPm;
  this.yp = ypPm;
  // Set initial rotation (radians).
  //if (this.ind == 1) { this.setRot(MATH_PI*0.25); } else { this.setRot(MATH_PI*0.25); }
  this.setRot(MATH_PI * 0.25);
  // Rotational speed (radians/frame).
  var sgn = this.ind == 0 ? 1 : -1;
  this.rotSpd = sgn * 0.035;
  this.cv = cvPm;

  this.init();
};

/**
 * Initialize.
 */
Wheel.prototype.init = function () {
  // link to main
  this.m = suite.machine;
};

/**
 * Update function.
 */
Wheel.prototype.upd = function () {
  this.sinAng = Math.sin(this.rot);
  this.cosAng = Math.cos(this.rot);
  // Update my nubs.
  this.nub0.upd();
  this.nub1.upd();
};

/**
 * Redraw function.
 */
Wheel.prototype.redraw = function () {
  // Update my nubs.
  this.nub0.redraw();
  this.nub1.redraw();
};

/**
 * Set rotation.
 */
Wheel.prototype.setRot = function (r) {
  this.rot = r;
};

/**
 * @fileoverview This file contains the Nub class.
 * @author Alexander Chen alex@chenalexander.com
 * @version 0.1
 */

/**
 * Constants definition.
 */

// Radius to draw circle.
var RAD_NORM = 6;
// Radius of circle when user is rolled over
var RAD_OVER = 15;
// My radius while grabbed
var RAD_GRAB = 10;
// radius easing ratio 0 to 1
var RAD_EASE = 0.4;
// Ease towards orbit when grabbed
var EASE_ORBIT_GRAB = 0.2;
// Ease towards new orbit when follower
var EASE_ORBIT_FOLLOW = 0.02;
// Ease towards orbit when released, going back to wheel
var EASE_ORBIT_RESTORE = 0.02;
// Ease towards new orbit center when grabbed
var EASE_CENTER_GRAB = 0.3;
// Ease center position when released, going back to wheel
var EASE_CENTER_RESTORE = 0.015;
// Ease towards new orbit center when following
var EASE_CENTER_FOLLOW_MIN = 0.04;
var EASE_CENTER_FOLLOW_MAX = 0.01;
// Ease towards new orbit size and position while a loader
var EASE_ORBIT_LOADER = 0.003;
var EASE_CENTER_LOADER = 0.03;
//
var EASE_ORBIT_EXIT_LOADER = 0.1; // Make it go back really fast
var EASE_CENTER_EXIT_LOADER = 0.1; // Make it go back really fast

// Trail start and end opacity
var TRAIL_OPAC_MIN = 0.04;
var TRAIL_OPAC_MAX = 0.5;
// At what point along the trail (0 to 1) do we start fading back out
var TRAIL_FADEOUT = 0.6;
// How many past points to store for trail?
var TRAIL_PTS = 24;
// Sample rate for trails (don't need to update every frame)
var TRAIL_SAMPLE = 4;
// Radius of how close user needs to be to rollover a nub
// Make this squared, so we don't have to do sqrt for distance.
// e.g. For distance radius of 10, set this to 100.
var ROLLOVER_RAD_SQ = 3500;
// How many strings can we pluck in one frame
var PLUCK_FRAME_MAX = 2;
// Orbit when I am a follower
var ORBIT_FOLLOW_MIN = WHEEL_RADIUS * 0.3;
var ORBIT_FOLLOW_MAX = WHEEL_RADIUS * 0.5;
// Orbit if I am the preloader nub
var ORBIT_LOADER = 35;
// Orbit when I am being dragged
var ORBIT_GRAB = 15;
// Cap speed after user releases. Give it max speed so it can't fly off
// Also give minimum so it has a little delay when released
var THROW_SPD_MAX = 23;
var THROW_SPD_MIN = 6;

/**
 * Builds a new Nub.
 * @class This is the Nub class.
 * @constructor
 * @param
 */
var Nub = function (indPm, indAllPm, machinePm, wheelPm, cvPm) {
  // Store my actual current and previous position.
  this.xp0;
  this.yp0;
  this.xp1;
  this.yp1;
  // Store the position that we would want to be at on the wheel
  this.xpw;
  this.ypw;
  // as point objects
  this.pt0 = new Point();
  this.pt1 = new Point();
  // link to my wheel
  this.wheel = wheelPm;

  this.machine = machinePm;
  // My index 0 or 1 within wheel.
  this.ind = indPm;
  // My index 0, 1, 2, 3 within overall.
  this.indAll = indAllPm;
  // Canvas object.
  this.cv = cvPm;
  // The current center of my orbit and target
  this.xpOrbit = this.xpOrbitTarg = this.wheel.xp;
  this.ypOrbit = this.ypOrbitTarg = this.wheel.yp;
  // My current and target orbit (radius)
  this.orbit = this.orbitTarg = WHEEL_RADIUS;
  // My current radius
  this.rad = RAD_NORM;
  // My target radius
  this.radTarg = RAD_NORM;
  // My current scale, 0 (small size) to 1 (rollover size)
  this.scaleRat = 0;
  // velocity
  this.velX = 0;
  this.velY = 0;
  // dampen velocity with this friction
  this.dampVel = 0.93;
  // Array of past points nub has traveled.
  this.arrTrail = new Array(TRAIL_PTS);
  // General frame counter - start at different point to offset when we'll update trails
  this.frameCt = this.indAll;
  // Current speed.
  this.spd = 0;
  // Is mouse rolled over me.
  this.isMouseOver = false;
  // Is mouse holding me
  this.isGrabbed = false;
  // Am I currently in follow mode
  this.isFollowing = false;
  // First time running?
  this.isFirstRun = true;
  // Have I entered yet, or still in waiting mode?
  this.hasEntered = false;
  // Am I in loading mode?
  this.isLoading = false;
  // When I am just tossed, as it is recovering to a halt.
  this.isTossing = false;
  this.init();
};

Nub.prototype.init = function () {
  this.m = this.machine;
};

/**
 * Update function.
 */
Nub.prototype.upd = function () {
  // If we're still loading and it's not the loader clip, don't do it
  if (!this.hasEntered) return;
  this.updPos();
  this.updInteract();
};

/**
 * Update function.
 */
Nub.prototype.updInteract = function () {
  // set my position based on wheel's rotation
  // don't do it on the first run
  if (this.isFirstRun) {
    this.isFirstRun = false;
    return;
  }
  // Don't do it if we skipped too far (this happens on loop around)
  if (this.spd > SPD_IGNORE_MAX) return;
  //
  var xi;
  var yi;
  var th;
  var ctPluck = 0;

  // go through threads
  for (var i = 0; i < this.m.arrThreads.length; i++) {
    th = this.m.arrThreads[i];
    // find line intersection
    var pt = lineIntersect(this.pt0, this.pt1, th.pt0, th.pt1);
    // did we get a point?
    if (pt == null) continue;
    xi = pt.x;
    yi = pt.y;
    // if it's not already grabbed, grab it
    if (!th.isGrabbed && !isNaN(xi) && !isNaN(yi)) {
      if (this.spd > SPD_GRAB) {
        // brush over thread
        th.pluck(xi, yi, true, this);
        // Grabbed too many?
        ctPluck++;
        if (ctPluck > PLUCK_FRAME_MAX) break;
      } else {
        // brush over thread
        th.grab(xi, yi, true, this);
        break;
      }
      // if user is holding it, NEED TO DROP IT -
      // if (th.isGrabbed) th.drop();
    }
  }
};

/**
 * Update loop run every frame, triggered by #upd.
 */
Nub.prototype.updPos = function () {
  // Now update the speed of my travel.
  // how much time has elapsed since last update?
  var d = new Date();
  this.t1 = d.getTime() / 1000;
  var elap = this.t1 - this.t0;
  this.t0 = this.t1;

  // dampen velocity
  this.velX *= this.dampVel;
  this.velY *= this.dampVel;
  if (Math.abs(this.velX) < 0.5) this.velX = 0;
  if (Math.abs(this.velY) < 0.5) this.velY = 0;
  // Where would we go if it was purely on velocity?
  this.xpv = this.xp0 + this.velX;
  this.ypv = this.yp0 + this.velY;

  // Update size of the dot.
  if (this.rad != this.radTarg) {
    var dr = this.radTarg - this.rad;
    if (Math.abs(dr) < 1) {
      this.rad = this.radTarg;
    } else {
      this.rad += dr * RAD_EASE;
    }
  }

  // Set the actual position.
  if (Math.abs(this.velX) > 0 || Math.abs(this.velY) > 0) this.isTossing = true;
  else this.isTossing = false;

  // While we are in tossing mode, just set it based on velocity
  if (this.isTossing) {
    this.setPos(this.xpv, this.ypv);
    this.xpOrbit = this.xpv;
    this.ypOrbit = this.ypv;
    this.orbit = 0;

    // Otherwise, we want to use the wheel position, orbiting mode
  } else {
    // If user is holding a nub
    if (this.machine.isHoldingNub) {
      // Ease towards user position.
      this.xpOrbitTarg = this.machine.getUserX();
      this.ypOrbitTarg = this.machine.getUserY();
    } else if (this.isMouseOver) {
      this.xpOrbitTarg = this.machine.getUserX();
      this.ypOrbitTarg = this.machine.getUserY();
      // Else user is not holding a nub,  use wheel anchor positions as target
    } else if (!this.isLoading) {
      // Target position for orbit
      this.xpOrbitTarg = this.wheel.xp;
      this.ypOrbitTarg = this.wheel.yp;
    } else {
      // Else it's the loader nub. Don't need to set orbit position every frame.
      // TEMPORARY! seeing if it works
      this.xpOrbitTarg = this.wheel.xp;
      this.ypOrbitTarg = this.wheel.yp;
    }

    // Ease towards new orbit radius
    // If we're moused over, overwrite it with a zero value orbit
    var orbitTargTrue = this.isMouseOver ? 0 : this.orbitTarg;
    if (this.orbit != orbitTargTrue) {
      this.orbit += (orbitTargTrue - this.orbit) * this.easeOrbit;
      if (Math.abs(this.orbitTarg - this.orbit) < 1)
        this.orbit = this.orbitTarg; // Close enough?
    }
    // Ease x towards orbit center
    if (this.xpOrbit != this.xpOrbitTarg) {
      this.xpOrbit += (this.xpOrbitTarg - this.xpOrbit) * this.easeCenter;
      if (Math.abs(this.xpOrbitTarg - this.xpOrbit) < 1)
        this.xpOrbit = this.xpOrbitTarg; // Close enough?
    }
    // Ease y towards orbit center
    if (this.ypOrbit != this.ypOrbitTarg) {
      this.ypOrbit += (this.ypOrbitTarg - this.ypOrbit) * this.easeCenter;
      if (Math.abs(this.ypOrbitTarg - this.ypOrbit) < 1)
        this.ypOrbit = this.ypOrbitTarg; // Close enough?
    }

    // Set new positions of nubs based on wheel rotation
    if (this.ind == 0) {
      this.xpw = this.xpOrbit + this.wheel.cosAng * this.orbit;
      this.ypw = this.ypOrbit + this.wheel.sinAng * this.orbit;
    } else {
      this.xpw = this.xpOrbit - this.wheel.cosAng * this.orbit;
      this.ypw = this.ypOrbit - this.wheel.sinAng * this.orbit;
    }

    // First time running, initialize position to the wheel position
    if (this.isFirstRun) {
      // this.isFirstRun = false; (It sets isFirstrun to false in updInteract)
      this.xp0 = this.xp1 = this.xpw;
      this.yp0 = this.yp1 = this.ypw;
      // Initialize trail array.
      for (var i = 0; i < TRAIL_PTS; i++) {
        this.arrTrail[i] = new Point(this.xpw, this.ypw);
      }
    }
    // set it
    this.setPos(this.xpw, this.ypw);
  }

  // change in position
  this.dx = this.xp1 - this.xp0;
  this.dy = this.yp1 - this.yp0;
  // update point objects
  this.pt0.x = this.xp0;
  this.pt0.y = this.yp0;
  this.pt1.x = this.xp1;
  this.pt1.y = this.yp1;
  // increment
  this.xp0 = this.xp1;
  this.yp0 = this.yp1;
  // how far did we go in this frame
  this.dist = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
  // store that as my speed, how many px i'm going in this frame
  //this.spd = this.dist/elap;
  this.spd = this.dist;
  // Take sample point for trail.
  if (this.frameCt % TRAIL_SAMPLE == 0) {
    this.arrTrail.shift();
    this.arrTrail[TRAIL_PTS - 1] = new Point(this.xp0, this.yp0);
  }
  // Check all points in my trail against bounding box
  for (var i = 0; i < this.arrTrail.length; i++) {
    this.m.checkBoxLimit(this.arrTrail[i].x, this.arrTrail[i].y);
  }
  this.frameCt++;
};

/**
 * Set me as the loading nub.
 */
Nub.prototype.enter = function () {
  this.hasEntered = true;
  this.isLoading = true;

  // enters first
  if (this.indAll == 0) {
    this.xpOrbit = -150;
    this.ypOrbit = this.m.height * 0.6;
    this.orbit = ORBIT_LOADER * 0.3;
    // enters third
  } else if (this.indAll == 1) {
    this.xpOrbit = this.m.width * 1.0;
    this.ypOrbit = -this.m.height * 0.9;
    this.orbit = ORBIT_LOADER * 5.5;
    // enter second
  } else if (this.indAll == 2) {
    this.xpOrbit = -this.m.width * 1.5;
    this.ypOrbit = this.m.height * 1.0;
    this.orbit = ORBIT_LOADER * 6;
    // enters last
  } else if (this.indAll == 3) {
    this.xpOrbit = this.m.width * 1.2;
    this.ypOrbit = -this.m.height * 0.8;
    this.orbit = ORBIT_LOADER * 1.5;
  }
  // Set target center position
  // this.xpOrbitTarg = 0;
  //this.ypOrbitTarg = this.ypOrbit = this.machine.arrThreads[this.indAll*2+1].yp1;
  //
  this.radTarg = RAD_NORM; // Set new target radius size

  // TEMPORARY! To see if it's seamless.
  this.orbitTarg = WHEEL_RADIUS;
  this.easeOrbit = EASE_ORBIT_LOADER; // Make it go back really fast
  this.easeCenter = EASE_CENTER_LOADER; // Make it go back really fast
  this.radTarg = RAD_NORM;
};

/**
 * Release me from loading mode
 */
Nub.prototype.exitLoader = function () {
  this.isLoading = false;
  this.orbitTarg = WHEEL_RADIUS;

  this.easeOrbit = EASE_ORBIT_EXIT_LOADER; // Make it go back really fast
  this.easeCenter = EASE_CENTER_EXIT_LOADER; // Make it go back really fast
  this.radTarg = RAD_NORM;
};

/**
 * Roll over.
 */
Nub.prototype.rollOver = function () {
  this.isMouseOver = true;
  this.radTarg = RAD_OVER; // Set new target radius
};

/**
 * Roll out.
 */
Nub.prototype.rollOut = function () {
  this.isMouseOver = false;
  this.radTarg = RAD_NORM; // Set new target radius
};

/**
 * Grab this nub.
 */
Nub.prototype.grab = function () {
  this.velX = this.velY = 0; // Snap velocity to zero when grabbed.

  this.easeOrbit = EASE_ORBIT_GRAB;
  this.easeCenter = EASE_CENTER_GRAB;

  this.isGrabbed = true;
  this.radTarg = RAD_GRAB; // Set new target radius size
  this.orbitTarg = ORBIT_GRAB; // Set new target orbit size

  // Start at random point
  var ind = Math.floor(Math.random() * NUBS);
  if (ind == NUBS) ind = NUBS - 1;
  // Initialize the followers
  for (var i = 0; i < NUBS; i++) {
    var n = this.machine.arrNubs[ind];
    if (n != this) {
      n.follow(i);
    }
    ind = (ind + 1) % NUBS;
  }
};

/**
 * Release this nub.
 */
Nub.prototype.drop = function () {
  this.isGrabbed = false;
  this.orbitTarg = WHEEL_RADIUS;

  this.easeOrbit = EASE_ORBIT_RESTORE;
  this.easeCenter = EASE_CENTER_RESTORE;
  this.radTarg = RAD_NORM;

  // store velocity as the difference of the last two points
  this.velX = this.m.dx;
  this.velY = this.m.dy;
  var vxa = Math.abs(this.velX);
  var vya = Math.abs(this.velY);

  // Limit it to minimum and maximum
  if (vxa > THROW_SPD_MAX) {
    this.velX = (vxa / this.velX) * THROW_SPD_MAX;
  } else if (vxa < THROW_SPD_MIN) {
    // Since user wasn't moving, need to use our own dx.
    if (this.dx == 0)
      this.velX = (Math.random() > 0.5 ? -1 : 1) * THROW_SPD_MIN;
    // don't divide by zero
    else this.velX = (Math.abs(this.dx) / this.dx) * THROW_SPD_MIN;
  }

  if (vya > THROW_SPD_MAX) {
    this.velY = (vya / this.velY) * THROW_SPD_MAX;
  } else if (vya < THROW_SPD_MIN) {
    // Since user wasn't moving, need to use our own dx.
    if (this.dy == 0)
      this.velY = (Math.random() > 0.5 ? -1 : 1) * THROW_SPD_MIN;
    // don't divide by zero
    else this.velY = (Math.abs(this.dy) / this.dy) * THROW_SPD_MIN;
  }

  var spd = Math.sqrt(vxa * vxa + vya * vya);
  // tell the followers to stop following
  var ct = 1;
  var nub;
  for (var i = 0; i < NUBS; i++) {
    nub = this.machine.arrNubs[i];
    if (nub != this && nub.hasEntered)
      nub.unfollow(this, this.velX, this.velY, ct / NUBS);
    ct++;
  }
};

/**
 * This nub starts following.
 */
Nub.prototype.follow = function (indPm) {
  var r = indPm / (NUBS - 1);
  this.orbitTarg = lerp(ORBIT_FOLLOW_MIN, ORBIT_FOLLOW_MAX, r);
  this.easeCenterFollow = lerp(
    EASE_CENTER_FOLLOW_MIN,
    EASE_CENTER_FOLLOW_MAX,
    r
  );

  this.easeOrbit = EASE_ORBIT_FOLLOW;
  this.easeCenter = this.easeCenterFollow;
};

/**
 * This nub ceases following.
 */
Nub.prototype.unfollow = function (nubSource, vx, vy, damp) {
  // Make it half use the source node's velocity, and half steer the direction towards the source node.
  var dx = nubSource.xp1 - this.xp1;
  var dy = nubSource.yp1 - this.yp1;
  //
  var r = 0.05; // How much to steer towards the source node (0 to 1)
  this.velX = (dx * r + vx * (1 - r)) * damp;
  this.velY = (dy * r + vy * (1 - r)) * damp;
  this.orbitTarg = WHEEL_RADIUS;
  this.easeOrbit = EASE_ORBIT_RESTORE;
  this.easeCenter = EASE_CENTER_RESTORE;
};

/**
 * Check mouse over.
 */
Nub.prototype.checkMouseOver = function () {
  // If mouse is already rolled over another nub, don't bother.
  var dx = this.machine.getUserX() - this.xp1;
  var dy = this.machine.getUserY() - this.yp1;
  var distSq = dx * dx + dy * dy;
  return distSq < ROLLOVER_RAD_SQ;
};

/**
 * Run on the first run when we return from the background
 */
Nub.prototype.returnFromBackground = function () {
  // Initialize trail array.
  for (var i = 0; i < TRAIL_PTS; i++) {
    this.arrTrail[i] = new Point(this.xp0, this.yp0);
  }
};

/**
 * Redraw function.
 */
Nub.prototype.redraw = function () {
  // If we're still loading and it's not the loader clip, don't do it
  if (!this.hasEntered) return;

  this.cv.beginPath();
  this.cv.fillStyle = "#FFFFFF";
  this.cv.arc(
    this.xp1 + this.m.xo,
    this.yp1 + this.m.yo,
    this.rad,
    0,
    2 * MATH_PI
  );
  this.cv.fill();
  this.cv.closePath();

  var x0, y0, x1, y1, x2, y2, xh0, yh0, xh1, yh1, opac, rat;

  // if we're in the background, don't even draw the trail
  if (this.machine.isInBackground) return;

  x0 = this.arrTrail[0].x;
  y0 = this.arrTrail[0].y;
  x1 = this.arrTrail[1].x;
  y1 = this.arrTrail[1].y;

  // How close to the nub do we want to get? - should be TRAIL_PTS-1 or lower.
  var TRAIL_PTS_LIM = TRAIL_PTS - 2;
  // draw trail
  for (var i = 1; i < TRAIL_PTS_LIM; i++) {
    // Ratio 0 to 1 along the trail
    rat = (i - 1) / (TRAIL_PTS_LIM - 2);
    // Our current point.
    x2 = this.arrTrail[i].x;
    y2 = this.arrTrail[i].y;

    // Calculate first halfway point
    xh0 = x0 + (x1 - x0) * 0.5;
    yh0 = y0 + (y1 - y0) * 0.5;
    // If it's the second point, just break here.
    if (i == 1) continue;
    // Else calculate next halfway point
    xh1 = x1 + (x2 - x1) * 0.5;
    yh1 = y1 + (y2 - y1) * 0.5;
    //
    this.cv.beginPath();
    this.cv.lineWidth = 1;
    // calculate opacity.
    if (rat < TRAIL_FADEOUT) {
      opac = lerp(TRAIL_OPAC_MIN, TRAIL_OPAC_MAX, rat / TRAIL_FADEOUT);
    } else {
      opac = lerp(
        TRAIL_OPAC_MAX,
        TRAIL_OPAC_MIN,
        (rat - TRAIL_FADEOUT) / (1 - TRAIL_FADEOUT)
      );
    }
    this.cv.strokeStyle = "rgba(255,255,255," + opac + ")";
    this.cv.moveTo(this.m.xo + xh0, this.m.yo + yh0);
    this.cv.quadraticCurveTo(
      this.m.xo + x1,
      this.m.yo + y1, // First control point
      this.m.xo + xh1,
      this.m.yo + yh1 // End anchor point
    );
    // increment points
    x0 = x1;
    y0 = y1;
    x1 = x2;
    y1 = y2;
    //
    this.cv.stroke();
    this.cv.closePath();
  }
};

/**
 * Update function.
 */
Nub.prototype.setPos = function (x, y) {
  this.xp1 = x;
  this.yp1 = y;
};

/**
 * Common functions below
 */

/**
 * Linear interpolation
 * For example, a value of t = 0.5 would return halfway between
 * a and b.
 * @param {number} a is the first value.
 * @param {number} b is the second value.
 * @param {number} t is a ratio from 0 to 1.
 * @return {number} number in the range a to b, based on t.
 */
var lerp = function (a, b, t) {
  return a + (b - a) * t;
};

/**
 * Limit a given number if it is outside of given range.
 * It will cap the value n if it outside of the limit, otherwise
 * it will just return n if it's within the acceptable range.
 * @param {number} n is the value we want to limit.
 * @param {number} n0 is the lower limit.
 * @param {number} n1 is the upper limit.
 * @return {number} a numer within the range n0 to n1.
 */
var lim = function (n, n0, n1) {
  if (n < n0) {
    return n0;
  } else if (n >= n1) {
    return n1;
  } else {
    return n;
  }
};

/**
 * Takes a value as well as an upper and lower limit, and returns a
 * ratio 0 to 1, based on where that value sits. Assumes that
 * a >= a0 and a <= a1.
 * @param {number} a is the value.
 * @param {number} a0 is the lower limit.
 * @param {number} a1 is the upper limit.
 * @return {number} A ratio 0 to 1.
 */
var norm = function (a, a0, a1) {
  return (a - a0) / (a1 - a0);
};

/**
 * Takes a value and returns -1 or 1 if it's positive or negative
 * @param {number} n is the value.
 * @return {number} -1 if the value is negative, 1 if it's positive
 */
var sign = function (n) {
  if (n >= 0) {
    return 1;
  } else {
    return -1;
  }
};

/**
 * Linear interpolate between two colors, each as RGBA array.
 * @param {array} a First RGBA array color.
 * @param {array} b Second RGBA array color.
 * @param {number} t ratio 0 to 1.
 * @return {array} interpolated value.
 */
var lerpColor = function (a, b, t) {
  var c1 = lerp(a[0], b[0], t);
  var c2 = lerp(a[1], b[1], t);
  var c3 = lerp(a[2], b[2], t);
  var c4 = lerp(a[3], b[3], t);
  return [c1, c2, c3, c4];
};

/**
 * Takes rgb(#,#,#) or rgba(#,#,#) and return hex string.
 * @param color is rgb(#,#,#) or rgba(#,#,#).
 * @return corresponding hex value.
 */
function rgbToHex(color) {
  var m = /rgba?\((\d+), (\d+), (\d+)/.exec(c);
  return m ? "#" + ((m[1] << 16) | (m[2] << 8) | m[3]).toString(16) : c;
}

/**
 * Convert a hex value to its decimal value.
 * @param {hex} hex value to convert.
 * @return {array} array with three values.
 */
function hex2rgb(hex) {
  // Remove the '#' char - if there is one.
  if (hex.charAt(0) == "#") hex = hex.slice(1);
  hex = hex.toUpperCase();
  var hex_alphabets = "0123456789ABCDEF";
  var value = new Array(3);
  var k = 0;
  var int1, int2;
  for (var i = 0; i < 6; i += 2) {
    int1 = hex_alphabets.indexOf(hex.charAt(i));
    int2 = hex_alphabets.indexOf(hex.charAt(i + 1));
    value[k] = int1 * 16 + int2;
    k++;
  }
  return value;
}

/**
 * Takes an array of three colors as RGB values and converts to
 * a string rgb(#,#,#)'
 * @param {Array} Array of three numbers
 * @return rgb value.
 */
var getRgb = function (color) {
  var r = Math.round(color[0]);
  var g = Math.round(color[1]);
  var b = Math.round(color[2]);
  return "rgb(" + r + "," + g + "," + b + ")";
};

/**
 * Calculates line segment intersection AB and EF.
 * Takes four {@link #Point} instances and returns a {@link #Point}
 * instance (or null if they do not intersect)
 * @param {Object} A Point object, start of first segment.
 * @param {Object} B Point object, end of first segment.
 * @param {Object} E Point object, start of second segment.
 * @param {Object} E Point object, end of second segment.
 * @return {Object} Point of intersection, or null if no intersection
 */
var lineIntersect = function (A, B, E, F) {
  var ip, a1, a2, b1, b2, c1, c2;
  // calculate
  a1 = B.y - A.y;
  a2 = F.y - E.y;
  b1 = A.x - B.x;
  b2 = E.x - F.x;
  c1 = B.x * A.y - A.x * B.y;
  c2 = F.x * E.y - E.x * F.y;
  // det
  var det = a1 * b2 - a2 * b1;
  // if lines are parallel
  if (det == 0) {
    return null;
  }
  // find point of intersection
  var xip = (b1 * c2 - b2 * c1) / det;
  var yip = (a2 * c1 - a1 * c2) / det;
  // now check if that point is actually on both line
  // segments using distance
  if (
    Math.pow(xip - B.x, 2) + Math.pow(yip - B.y, 2) >
    Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2)
  ) {
    return null;
  }
  if (
    Math.pow(xip - A.x, 2) + Math.pow(yip - A.y, 2) >
    Math.pow(A.x - B.x, 2) + Math.pow(A.y - B.y, 2)
  ) {
    return null;
  }
  if (
    Math.pow(xip - F.x, 2) + Math.pow(yip - F.y, 2) >
    Math.pow(E.x - F.x, 2) + Math.pow(E.y - F.y, 2)
  ) {
    return null;
  }
  if (
    Math.pow(xip - E.x, 2) + Math.pow(yip - E.y, 2) >
    Math.pow(E.x - F.x, 2) + Math.pow(E.y - F.y, 2)
  ) {
    return null;
  }
  // else it's on both segments, return it
  return new Point(xip, yip);
};

/**
 * A simple point object that stores x as x coordinate, y as y coordinate.
 * @class This is the Point class.
 * @constructor
 * @param {number} px x coordinate for the point.
 * @param {number} px y coordinate for the point.
 */
var Point = function (px, py) {
  this.x = px;
  this.y = py;
};

/**
 * Update the x coordinate of the point.
 * @param {number} px x coordinate for the point.
 */
Point.prototype.setX = function (px) {
  this.x = px;
};

/**
 * Update the y coordinate of the point.
 * @param {number} py y coordinate for the point.
 */
Point.prototype.setY = function (py) {
  this.y = py;
};

var suite = {};

// How often to run our update function? In milliseconds. so 33 would be around 30 frames per second.
var UPDATE_INTERVAL = 33;
// How often to run our load update interval? (Not needed as often, just a timer.)
var LOAD_UPDATE_INTERVAL = 80;
// How many total notes/pitches do we have? Make sure this matches the compiled sound SWF.
var TOTAL_NOTES = 38;
// Initial tempo (beats per minute) and beats per second.
var BPM_NORM = 145;
// Mininum mouse speed in pixels per millisecond.
var MOUSE_SPEED_MIN = 70;
// Maximum mouse speed in pixels per millisecond.
var MOUSE_SPEED_MAX = 1500;
// The mouse will grab a thread if the average speed ratio is below this threshold.
var MOUSE_SPEED_RATIO_GRAB = 0.4;
// Number of measurements to consider when calculating average mouse speed.
var MOUSE_AVERAGE_COUNT = 5;
// Number of threads. Make this 8 to match the Bach musical grouping.
var TOTAL_THREADS = 8;
// How many total notes are in the song
var TOTAL_NOTES_IN_SONG = SONG_DATA_ARRAY.length;
// Subdivision of notes for each thread. 1 = Quarter notes, 2 = eighth, etc.
var NOTE_UNIT = 2;
// The value to multiply a length of string to move up one half-step, by Pythagorean scale.
var HALF_STEP_MULTIPLIER = 0.943874312681769;
// Maximum length for a thread, assigned to the lowest note.
var MAX_LENGTH = 590;
// Shortest length for the highest note, figured out mathematically.
var MIN_LENGTH = MAX_LENGTH * Math.pow(HALF_STEP_MULTIPLIER, TOTAL_NOTES - 1);
// Store PI as global constant.
var MATH_PI = Math.PI;
// Show framerate for testing?
var SHOW_FRAMERATE = false;
// Initialize mouse position on the page (Not constant)
var mouseX = 0,
  mouseY = 0;

var aboutURL = "http://www.chenalexander.com/Bach";

// Below what speed (px/frame) can a nub grab a thread instead of plucking it.
// Set this speed below the normal rate that nubs are traveling during a song
// to help performance.
var SPD_GRAB = 4;
// What speed (px/frame) do we ignore plucks.
// Helps when song loops, as dots skip impossible distance.
// Also helps when dragging very quickly over all strings, will ignore some
var SPD_IGNORE_MAX = 80;

// Mapping of MIDI notes from SONG_DATA_ARRAY into our musical note scale
var MIDI_MAP = {
  // Numerical keys.
  36: 0,
  37: 1,
  38: 2,
  39: 3,
  40: 4,
  41: 5,
  42: 6,
  43: 7,
  44: 8,
  45: 9,
  46: 10,
  47: 11,
  48: 12,
  49: 13,
  50: 14,
  51: 15,
  52: 16,
  53: 17,
  54: 18,
  55: 19,
  56: 20,
  57: 21,
  58: 22,
  59: 23,
  60: 24,
  61: 25,
  62: 26,
  63: 27,
  64: 28,
  65: 29,
  66: 30,
  67: 31,
  68: 32,
  69: 33,
  70: 34,
  71: 35,
  72: 36,
};

// the Web Audio "context" object
var context = null;
// Array to store audio buffers and filenames
var arrBuffers, arrUrl; // array of audio buffers

/**
 * Start the process once everything's loaded.
 */
suite.everythingIsReady = function () {
  if (suite.ready) {
    return;
  }
  suite.ready = true;
  // Tell machine it's ready.
  suite.machine.doneLoading();
};

/**
 * Start the loading process.
 */
suite.init = function () {
  suite.ready = false;
  suite.initMidiMap();

  // Create Web Audio Context, future proofed for future browsers
  contextClass =
    window.AudioContext ||
    window.webkitAudioContext ||
    window.mozAudioContext ||
    window.oAudioContext ||
    window.msAudioContext;
  if (contextClass) {
    context = new contextClass();
  } else {
    // Web Audio API not available. Ask user to use a supported browser.
  }

  // add resize listener
  window.addEventListener("resize", rsize, false);
  // mouse actions
  /*document.addEventListener('mousemove', function (e) {
        mouseX = e.pageX; mouseY = e.pageY;
    }, false);
    document.addEventListener('mousedown', function (e) {
        mousePressed = true;
        if (suite.machine.mouseDown != undefined) suite.machine.mouseDown(e);
        e.preventDefault();
    }, false);
    document.addEventListener('mouseup', function (e) {
        mousePressed = false;
        if (suite.machine.mouseUp != undefined) suite.machine.mouseUp(e);
    }, false);*/

  // initialize canvas
  suite.canvasEl = document.getElementById("main-canvas");
  suite.canvasObj = suite.canvasEl.getContext("2d");
  // Create guitar class.
  suite.machine = new Machine(suite.canvasObj);
  suite.indNoteLd = 0;
  // invoke resize listener once now
  rsize();

  // Build our machine.
  suite.machine.build();
  suite.machine.beginLoading();
  // Begin update loop.
  setInterval(updateLoop, UPDATE_INTERVAL);

  // -----------

  // Load in the audio files.
  // Create array of audio buffers
  arrBuffers = new Array(TOTAL_NOTES);
  // Create array of URL's
  arrUrl = new Array(TOTAL_NOTES);
  var midiValue, pre;
  for (var i = 0; i < TOTAL_NOTES; i++) {
    if (i < 10) pre = "0";
    else pre = "";
    arrUrl[i] = path + "/audio/harp_" + pre + i + ".mp3";
  }
  bufferLoader = new BufferLoader(context, arrUrl, finishedLoading);
  bufferLoader.load();
};

/**
 * Convert our MIDI_MAP into a numerical-indexed lookup array.
 */
suite.initMidiMap = function () {
  suite.arrMidiMap = new Array();
  var n;
  for (key in MIDI_MAP) {
    n = parseInt(key);
    suite.arrMidiMap[n] = MIDI_MAP[key];
  }
};

/**
 * Update loop run via setInterval (see everythingIsReady)
 */
var updateLoop = function () {
  suite.machine.upd();
};

// tempoary - put this in init function called from body.onLoad
init = function () {
  suite.init();
};

/**
 * Play note with given pitch, volume, pan.
 */
suite.playSound = function (pitchPm, volPm, panPm) {
  var n = pitchPm;
  var buffer = arrBuffers[n];
  var source = context.createBufferSource();
  source.buffer = buffer;
  // Create a gain node.
  var gainNode = context.createGain();
  source.connect(gainNode);
  gainNode.connect(context.destination);
  // Set volume
  gainNode.gain.value = volPm;
  source.start();
};

function finishedFile(bufferPm) {
  bufferLoader.finishedFile(bufferPm);
  // Which sound to load next.
  suite.indNoteLd++;
}

// what to do when we're done loading sounds
function finishedLoading(bufferListPm) {
  arrBuffers = bufferListPm;
  suite.soundAvailable = true;
  suite.soundReady = true;
  suite.everythingIsReady();
  //suite.machine.setGroup(0);
}

/**
 * Resize event, whenever browser is resized.
 * Stores new window width and height.
 */
var rsize = function () {
  width = window.innerWidth;
  height = window.innerHeight;
  if (suite.machine != null) suite.machine.rsize();
};

/**
 * For version testing purposes, get a variable out of URL
 * @param {Element} variable string (e.g. "id")
 * @return {number} variable value (e.g. 25)
 */
function getQueryVariable(variable) {
  var query = window.location.search.substring(1);
  var vars = query.split("&");
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split("=");
    if (pair[0] == variable) {
      return pair[1];
    }
  }
  return null;
}

// Enable debugging with the console.
if (!window.console) console = {};
console.log = console.log || function () {};
console.warn = console.warn || function () {};
console.error = console.error || function () {};
console.info = console.info || function () {};

// class:	BufferLoader
// ------------------------------------------------
var BufferLoader = function (contextPm, arrUrlPm, functionFinishedPm) {
  // audio context
  this.context = contextPm;
  // array of file url paths
  this.arrUrl = arrUrlPm;
  // a function
  this.functionFinished = functionFinishedPm;
  // array of buffers which I create
  this.arrBuffer = new Array();
  // which file are we on
  this.ind = 0;
};

// function:	init
// desc:
// ------------------------------------------------
BufferLoader.prototype.load = function () {
  // start loading the first one
  this.loadFile(0);
};

// function:	loadFile
// ------------------------------------------------
BufferLoader.prototype.loadFile = function (indPm) {
  var request = new XMLHttpRequest();
  var url = this.arrUrl[indPm];
  request.open("GET", url, true);
  request.responseType = "arraybuffer";
  var context = this.context;

  var onError = function () {
    // handle error
  };
  // Decode asynchronously
  request.onload = function () {
    // when it's done
    context.decodeAudioData(
      request.response,
      function (theBuffer) {
        finishedFile(theBuffer);
      },
      onError
    );
  };
  request.send();
};

// function:	finishedFile
// ------------------------------------------------
BufferLoader.prototype.finishedFile = function (bufferPm) {
  this.arrBuffer.push(bufferPm);
  // is that the last one?
  if (this.ind >= this.arrUrl.length - 1) {
    // done, call the finished function and return the array of buffers
    this.functionFinished(this.arrBuffer);
  } else {
    this.ind++;
    // load the next one
    this.loadFile(this.ind);
  }
};
